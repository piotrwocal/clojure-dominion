<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1422302999714">{:repl-history {:ide [], :local [&quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 2)\n     ;results-&gt;params\n     ;(map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(play-balanced-series )&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 2)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 2)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 2))\n     pprint)&quot; &quot;(subsets 1 (range 5))&quot; &quot;(subsets 2 (range 5))&quot; &quot;(subsets 5 (range 5))&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(use 'clojure.tools.trace)&quot; &quot;(use 'clojure.contrib.trace)&quot; &quot;(defn ^:dynamic fib [n] (if (&lt; n 2) n (+ (fib (- n 1)) (fib (- n 2)))))&quot; &quot;(dotrace [fib] (fib 3))&quot; &quot;(dotrace (subsets [2 (range 4)]))&quot; &quot;(defn subsets ^:dynamic\n  [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(dotrace [subsets] (subsets [2 (range 4)]))&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (= n 1) (map list items)\n    (empty? items) '()\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    (= n (count items)) items\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(dotrace [subsets] (subsets 3 (range 3)))&quot; &quot;(dotrace [subsets] (subsets 2 (range 3)))&quot; &quot;(dotrace [subsets] (subsets 1 (range 3)))&quot; &quot;map&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    ;(= n (count items)) items\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(dotrace [subsets] (subsets 2 (range 4)))&quot; &quot;(dotrace [subsets] (subsets 2 (range 5)))&quot; &quot;(def ^:dynamic dyn-subsets subsets) &quot; &quot;(dotrace [dyn-subsets] (dyn-subsets 2 (range 5)))&quot; &quot;(defmacro dbg[x] `(let [x# ~x] (println \&quot;dbg:\&quot; '~x \&quot;=\&quot; x#) x#))&quot; &quot;(println (+ (* 2 3) (dbg (* 8 9))))&quot; &quot;(dbg (subsets 2 (range 4)))&quot; &quot;(defn factorial [n]\n  (if (= n 0)\n    1\n    (* n (dbg (factorial (dec n))))))&quot; &quot;(factorial 10)&quot; &quot;(defn subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(trace-vars subsets)&quot; &quot;(subsets 2 (range 4))&quot; &quot;(untrace-vars subsets)&quot; &quot;(trace-vars permutations)&quot; &quot;(permutations [[1 2] [3 4] [5 6]])&quot; &quot;(deftest test-optimized-big-money\n  (are [card board hand]\n    (= card (optimized-big-money board hand))\n    {:province 1} init-board {:copper 8}\n    {:gold 1} init-board {:copper 6}\n    {:duchy 1} {:province 3 :gold 1 :duchy 1} {:copper 6}\n    {:silver 1} init-board {:copper 5}\n    {:silver 1} init-board {:copper 3}\n    {:silver 1} {:province 3 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {:estate 1} {:province 2 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {} init-board {:copper 2}))&quot; &quot;sdf&quot; &quot;(deftest test-optimized-big-money\n  (are [card board hand]\n    (= card (optimized-big-money board hand))\n    {:province 0} init-board {:copper 8}\n    {:gold 1} init-board {:copper 6}\n    {:duchy 1} {:province 3 :gold 1 :duchy 1} {:copper 6}\n    {:silver 1} init-board {:copper 5}\n    {:silver 1} init-board {:copper 3}\n    {:silver 1} {:province 3 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {:estate 1} {:province 2 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {} init-board {:copper 2}))&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (apply +\n         (map\n           (fn [[card count]] (* (stat (cards-stats card)) count))\n           cards)))&quot; &quot;(count-of :value init-board)&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (reduce\n    (fn [sum [card count]] (* (stat (cards-stats card)) count))\n           cards))&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (reduce\n    (fn [sum [card count]] (+ sum (* (stat (cards-stats card)) count)))\n           cards))&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (reduce\n    (fn [[card count] sum] (+ sum (* (stat (cards-stats card)) count)))\n           cards))&quot; &quot;(count-of :value init-cards)&quot; &quot;(let [player (atom init-player)\n        hand (take-hand! player)]\n    (is (= init-cards\n           (merge-with + hand (:cards @player))))\n    (is (= init-cards\n           (merge-with + hand (take-hand! player))))\n    (is (and (empty? (take-hand! player))\n             (empty? (:cards @player))\n             (empty? (:discarded @player)))))&quot; &quot;(can buy-? init-cards :province 8)&quot; &quot;(defn can-buy?\n  \&quot;Test if with board and money one can buy card\&quot;\n  [board card money]\n  (and (pos? (card board))\n       (&gt;= money (-&gt; cards-stats card :cost))))&quot; &quot;(defn can-buy?\n  \&quot;Test if with board and money one can buy card\&quot;\n  [board card money]\n  (and (pos? (card board 0))\n       (&gt;= money (-&gt; cards-stats card :cost))))&quot; &quot;(can-buy? init-board :province 5)&quot; &quot;(can-buy? init-board :province 8)&quot; &quot;(can-buy? init-cards :province 8)&quot; &quot;(defn play\n  [&amp; strategies]\n  (let [board (atom init-board)\n        players (map new-player strategies)]\n    (loop [moves '()\n           order (cycle players)]\n      (if (game-finish? board)\n        moves\n        (recur (conj moves (turn board (first order))) (rest order))))))&quot; &quot;(play province-gold-duchy-silver province-gold-silver)&quot; &quot;(play-series 2 province-gold-duchy-silver province-gold-silver)&quot; &quot;(play-series 2 optimized-big-money optimized-big-money)&quot; &quot;(play-series 2 (paramized-big-money* 4 5 2 3)\n             (paramized-big-money* 4 5 2 3))&quot; &quot;(play (paramized-big-money* 4 5 2 3)\n             (paramized-big-money* 4 5 2 3))&quot; &quot;@player&quot; &quot;(pprint @player)&quot; &quot;(turn board player)&quot; &quot;(play )&quot; &quot;(trace-vars turn)&quot; &quot;(defn play\n  [&amp; strategies]\n  (let [board (atom init-board)\n        players (map new-player strategies)]\n    (loop [moves '()\n           order (cycle players)\n           _ (println moves)]\n      (if (game-finish? board)\n        moves\n        (recur (conj moves (turn board (first order))) (rest order))))))&quot; &quot;(def player (new-player \&quot;test\&quot; optimized-big-money))&quot; &quot;(def board (atom init-board))&quot; &quot;(pprint (turn board player))&quot; &quot;(play optimized-big-money optimized-big-money)&quot; &quot;(play [\&quot;first\&quot; optimized-big-money]\n      [\&quot;second\&quot; optimized-big-money])&quot; &quot;(play [\&quot;1\&quot; optimized-big-money]\n      [\&quot;2\&quot; optimized-big-money])&quot; &quot;(pprint\n  (take-result\n    (play [\&quot;1\&quot; optimized-big-money]\n          [\&quot;2\&quot; optimized-big-money])))&quot; &quot;(defn count-points \n  [moves]\n  )&quot; &quot;(pprint (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money]))&quot; &quot;(map :name  (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money]))&quot; &quot;(distinct (map :name  (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money])))&quot; &quot;(count (distinct (map :name  (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money]))))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (map :name)\n     distinct\n     count)&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] {:name move (count-type move-1 :points)})))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map :name ))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move-1 :points)})))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move :points)})))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move :points)}))\n     merge)&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move :points)}))\n     (apply merge))&quot; &quot;(defn count-points\n  [moves]\n  (let [n (-&gt;&gt; moves (map :name) distinct count)\n        final-moves (take n moves)]\n    (apply merge (map (fn [move] {(:name move) (count-type move :points)})\n                      final-moves))))&quot; &quot;(defn play-series\n  [n &amp; strategies]\n  (-&gt;&gt; #(count-points (apply play strategies))\n       repeatedly\n       ((partial take n))\n       (map (partial apply max-key val))\n       (map key)\n       frequencies))&quot; &quot;(defn count-points\n  [moves]\n  (let [n (-&gt;&gt; moves (map :name) distinct count)\n        final-moves (take n moves)\n        single-result (fn [move] \n                        {(:name move) (count-type move :points)})]\n    (apply merge (map single-result final-moves))))&quot; &quot;(count-points\n  (play [\&quot;1\&quot; optimized-big-money]\n        [\&quot;2\&quot; optimized-big-money]))\n  &quot; &quot;(defn play-series\n  [n &amp; strategies]\n  (-&gt;&gt; #(count-points (apply play strategies))\n       repeatedly\n       (take n)\n       (map (partial apply max-key val))\n       (map key)\n       frequencies))&quot; &quot;(play-series 2 [\&quot;1\&quot; optimized-big-money]\n             [\&quot;2\&quot; optimized-big-money])\n  &quot; &quot;(defn neighbours\n  [params]\n  (-&gt;&gt; params\n       (map #(map (partial + %) (range -1 2)))\n       (map (partial filter #(and (&gt;= % 0) (&lt;= % 9))))))&quot; &quot;(neighbours [ 1 2 3 ])&quot; &quot;(for [i (range -1 2) v [1 2 3] [(+ i v)]])&quot; &quot;(map #(for [i (range -1 2) %] [(+ i v)]) [ 1 2 3])&quot; &quot;(for [i (range -1 2) v [1 2 3]] [(+ i v)])&quot; &quot;(neighbour-results 10 [ 5 4 2 1])&quot; &quot;(pprint )&quot; &quot;(defn neighbour-results\n  [n current-params]\n  (let [candidates (-&gt; current-params neighbours permutations)\n        current-startegy (params-&gt;strategy current-params)]\n    (-&gt;&gt; (map params-&gt;strategy candidates)\n         (map (partial play-balanced-series n current-startegy))\n         (map (partial apply max-key val))\n         (remove #(= (str current-params) (first %)))\n         (sort-by second &gt;))))&quot; &quot;(pprint (neighbour-results 10 [ 5 4 2 1]))&quot;], :remote []}}</component>
</project>