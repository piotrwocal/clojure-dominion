<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1422400050400">{:repl-history {:ide [], :local [&quot;(play )&quot; &quot;(trace-vars turn)&quot; &quot;(defn play\n  [&amp; strategies]\n  (let [board (atom init-board)\n        players (map new-player strategies)]\n    (loop [moves '()\n           order (cycle players)\n           _ (println moves)]\n      (if (game-finish? board)\n        moves\n        (recur (conj moves (turn board (first order))) (rest order))))))&quot; &quot;(def player (new-player \&quot;test\&quot; optimized-big-money))&quot; &quot;(def board (atom init-board))&quot; &quot;(pprint (turn board player))&quot; &quot;(play optimized-big-money optimized-big-money)&quot; &quot;(play [\&quot;first\&quot; optimized-big-money]\n      [\&quot;second\&quot; optimized-big-money])&quot; &quot;(play [\&quot;1\&quot; optimized-big-money]\n      [\&quot;2\&quot; optimized-big-money])&quot; &quot;(pprint\n  (take-result\n    (play [\&quot;1\&quot; optimized-big-money]\n          [\&quot;2\&quot; optimized-big-money])))&quot; &quot;(defn count-points \n  [moves]\n  )&quot; &quot;(pprint (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money]))&quot; &quot;(map :name  (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money]))&quot; &quot;(distinct (map :name  (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money])))&quot; &quot;(count (distinct (map :name  (play [\&quot;1\&quot; optimized-big-money]\n              [\&quot;2\&quot; optimized-big-money]))))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (map :name)\n     distinct\n     count)&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] {:name move (count-type move-1 :points)})))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map :name ))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move-1 :points)})))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move :points)})))&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move :points)}))\n     merge)&quot; &quot;(-&gt;&gt; (play [\&quot;1\&quot; optimized-big-money]\n           [\&quot;2\&quot; optimized-big-money])\n     (take 2)\n     (map (fn[move] { (:name move) (count-type move :points)}))\n     (apply merge))&quot; &quot;(defn count-points\n  [moves]\n  (let [n (-&gt;&gt; moves (map :name) distinct count)\n        final-moves (take n moves)]\n    (apply merge (map (fn [move] {(:name move) (count-type move :points)})\n                      final-moves))))&quot; &quot;(defn play-series\n  [n &amp; strategies]\n  (-&gt;&gt; #(count-points (apply play strategies))\n       repeatedly\n       ((partial take n))\n       (map (partial apply max-key val))\n       (map key)\n       frequencies))&quot; &quot;(defn count-points\n  [moves]\n  (let [n (-&gt;&gt; moves (map :name) distinct count)\n        final-moves (take n moves)\n        single-result (fn [move] \n                        {(:name move) (count-type move :points)})]\n    (apply merge (map single-result final-moves))))&quot; &quot;(count-points\n  (play [\&quot;1\&quot; optimized-big-money]\n        [\&quot;2\&quot; optimized-big-money]))\n  &quot; &quot;(defn play-series\n  [n &amp; strategies]\n  (-&gt;&gt; #(count-points (apply play strategies))\n       repeatedly\n       (take n)\n       (map (partial apply max-key val))\n       (map key)\n       frequencies))&quot; &quot;(play-series 2 [\&quot;1\&quot; optimized-big-money]\n             [\&quot;2\&quot; optimized-big-money])\n  &quot; &quot;(defn neighbours\n  [params]\n  (-&gt;&gt; params\n       (map #(map (partial + %) (range -1 2)))\n       (map (partial filter #(and (&gt;= % 0) (&lt;= % 9))))))&quot; &quot;(neighbours [ 1 2 3 ])&quot; &quot;(for [i (range -1 2) v [1 2 3] [(+ i v)]])&quot; &quot;(map #(for [i (range -1 2) %] [(+ i v)]) [ 1 2 3])&quot; &quot;(for [i (range -1 2) v [1 2 3]] [(+ i v)])&quot; &quot;(neighbour-results 10 [ 5 4 2 1])&quot; &quot;(pprint )&quot; &quot;(defn neighbour-results\n  [n current-params]\n  (let [candidates (-&gt; current-params neighbours permutations)\n        current-startegy (params-&gt;strategy current-params)]\n    (-&gt;&gt; (map params-&gt;strategy candidates)\n         (map (partial play-balanced-series n current-startegy))\n         (map (partial apply max-key val))\n         (remove #(= (str current-params) (first %)))\n         (sort-by second &gt;))))&quot; &quot;(pprint (neighbour-results 10 [ 5 4 2 1]))&quot; &quot;(range 0 10) &quot; &quot;(contains? (range 0 10) 9)&quot; &quot;(contains (range 0 10) 9)&quot; &quot;((set (range 0 10)) 9)&quot; &quot;((set (range 0 10)) 8)&quot; &quot;((set (range 0 10)) 1)&quot; &quot;((set (range 0 10)) 10)&quot; &quot;(neighbours [1 2 9])&quot; &quot;(defn neighbours\n  [params]\n  (-&gt;&gt; params\n     (map #(map (partial + %) (range -1 2)))\n     (map filter (set (range 0 10)))))&quot; &quot;(neighbours [0 2 9])&quot; &quot;(defn neighbours\n  [params]\n  (-&gt;&gt; params\n     (map #(map (partial + %) (range -1 2)))\n     (map (partial filter #(and (&gt;= % 0) (&lt;= % 9))))))&quot; &quot;(neighbours [1])&quot; &quot;(neighbours [1 2])&quot; &quot;(neighbours [0 2])&quot; &quot;(permutations (neighbours [0 2]))&quot; &quot;(permutation [1 2] [3 4])&quot; &quot;(permutation [[1 2] [3 4]])&quot; &quot;(permutations [[1 2] [3 4]])&quot; &quot;(neighbour-results 10 [5 7 2 1])&quot; &quot;(pprint (neighbour-results 10 [5 7 2 1]))&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(defn neighbour-results\n  \&quot;Takes n and input params for current strategy. For given input params\n  generates permutations of params neighbours and play n balanced series\n  games between current strategy and each neighbour strategy.\n  Returns sorted list of pairs 'strategy name/number of wins'\&quot;\n  [n input-params]\n  (let [candidates (-&gt; input-params neighbours permutations)\n        current-startegy (params-&gt;strategy input-params)]\n    (-&gt;&gt; (map params-&gt;strategy candidates)\n         (map (partial play-balanced-series n current-startegy))\n         (map (partial apply max-key val))\n         (remove #(= (str input-params) (first %)))\n         (sort-by second &gt;))))&quot; &quot;(use 'repl.tools.doc)&quot; &quot;(use 'repl.tools)&quot; &quot;(doc map)&quot; &quot;(use 'clojure.repl)&quot; &quot;(defn neighbour-results\n  \&quot;Takes n and input params for strategy. For given input params\n  generates permutations of params neighbours and play n balanced\n  series games between current strategy and each generated strategy.\n  Returns sorted list of pairs 'strategy name/number of wins'\&quot;\n  [n input-params]\n  (let [candidates (-&gt; input-params neighbours permutations)\n        current-startegy (params-&gt;strategy input-params)]\n    (-&gt;&gt; (map params-&gt;strategy candidates)\n         (map (partial play-balanced-series n current-startegy))\n         (map (partial apply max-key val))\n         (remove #(= (str input-params) (first %)))\n         (sort-by second &gt;))))&quot; &quot;(doc neighbour-results)&quot; &quot;(use 'clojure.java.browse)&quot; &quot;(browse-url www.google.com)&quot; &quot;(browse-url \&quot;www.google.com\&quot;)&quot; &quot;(browse-url \&quot;www.gmail.com\&quot;)&quot; &quot;(neighbour-results 10 [7 5 2 1])&quot; &quot;(pprint (neighbour-results 10 [7 5 2 1]))&quot; &quot;(next-best-params 10 [7 5 2 1])&quot; &quot;(&lt;= 3 3)&quot; &quot;(&lt;= 4 3)&quot; &quot;(next-best-params 10 [5 5 2 3])&quot; &quot;(neighbour-results 10 [5 5 2 3])&quot; &quot;(pprint (neighbour-results 50 [5 5 2 3]))&quot; &quot;(defn best-neighbour-params\n  [n params]\n  (-&gt;&gt; (neighbour-results n params) first key read-string vec))&quot; &quot;(best-neighbour-params 10 [5 5 2 3])&quot; &quot;(take 10 (iterate (partial best-neighbour-params 10) [5 5 2 3]))  &quot; &quot;(pprint (take 10 (iterate (partial best-neighbour-params 5) [5 5 2 3])))  &quot; &quot;c&quot; &quot;(-&gt;&gt; [5 5 2 3]\n     (iterate (partial best-neighbour-params 5))\n     (take 10)\n     pprint)\n&quot; &quot;(def next-best (iterate (partial best-neighbour-params 5) [5 5 2 3]))&quot; &quot;(take 2 next-best)&quot; &quot;(take 3 next-best)&quot; &quot;(defn first-duplicate \n  ([coll]\n    (first-duplicate coll {}))\n  ([coll elements]\n    (let [x (first coll)]\n      (if ))))&quot; &quot;(#{ 1 2 } 2)&quot; &quot;(defn first-duplicate \n  ([coll]\n    (first-duplicate coll #{}))\n  ([coll elements]\n    (let [x (first coll)]\n      (if (elements x)\n        x\n        (recur (rest coll) (conj elements x))))))&quot; &quot;(first-duplicate [1 2 3 4 3 2 4])&quot; &quot;(first-duplicate (iterate (partial best-neighbour-params 5) [5 5 2 3]))&quot; &quot;(defn first-duplicate \n  ([coll]\n    (first-duplicate coll []))\n  ([coll elements]\n    (let [x (first coll)]\n      (if (elements x)\n        [x elements]\n        (recur (rest coll) (conj elements x))))))&quot; &quot;(conj [] 1)&quot; &quot;(conj [1] 2)&quot; &quot;(defn first-duplicate \n  ([coll]\n    (first-duplicate coll []))\n  ([coll elements]\n    (let [x (first coll)]\n      (if (contains? elements x)\n        [x elements]\n        (recur (rest coll) (conj elements x))))))&quot; &quot;(pprint (first-duplicate (iterate (partial best-neighbour-params 5) [5 5 2 3])))&quot; &quot;(find-duplicate (iterate (partial best-neighbour-params 5)))&quot; &quot;(find-duplicate (iterate (partial best-neighbour-params 5) [5 5 2 3]))&quot;], :remote []}}</component>
</project>