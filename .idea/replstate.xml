<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1453237038458">{:repl-history {:ide [], :local [&quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (map unique-head)&quot; &quot;pprint&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (map unique-head) \n     pprint)&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (apply map unique-head)\n     pprint)&quot; &quot;(map unique-head '(\\b \\c \\d \\a \\b))&quot; &quot;(unique-head (range 10))&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     pprint)&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (map count)\n     pprint)&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (map unique-head)\n     pprint)&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (map unique-head)\n     (sort-by count &gt;)\n     first)&quot; &quot;(-&gt;&gt; (take-while not-empty (iterate rest (seq \&quot;abcdab\&quot;))) \n     (map (fn [xs]\n            (if (= (count xs) (count (set xs)))\n              xs\n              (recur (butlast xs)))))\n     (sort-by count &gt;)\n     first)&quot; &quot;(defn longest-unique [xs]\n  (-&gt;&gt; (take-while not-empty (iterate rest (seq xs))) \n     (map unique-head)\n     (sort-by count &gt;)\n     first))&quot; &quot;(longest-unique \&quot;abcdabcdea\&quot;)&quot; &quot;(longest-unique (concat (range 5) (range 10) (range 5)))&quot; &quot;(doc count)&quot; &quot;(doc butlast)&quot; &quot;(doc pmap)&quot; &quot;(def village\n  [\n   {:home :north :family \&quot;smith\&quot; :name \&quot;sue\&quot; :age 37 :sex :f :role :parent}\n   {:home :north :family \&quot;smith\&quot; :name \&quot;stan\&quot; :age 35 :sex :m :role :parent}\n   {:home :north :family \&quot;smith\&quot; :name \&quot;simon\&quot; :age 7 :sex :m :role :child}\n   {:home :north :family \&quot;smith\&quot; :name \&quot;sadie\&quot; :age 5 :sex :f :role :child}\n\n   {:home :south :family \&quot;jones\&quot; :name \&quot;jill\&quot; :age 45 :sex :f :role :parent}\n   {:home :south :family \&quot;jones\&quot; :name \&quot;jeff\&quot; :age 45 :sex :m :role :parent}\n   {:home :south :family \&quot;jones\&quot; :name \&quot;jackie\&quot; :age 19 :sex :f :role :child}\n   {:home :south :family \&quot;jones\&quot; :name \&quot;jason\&quot; :age 16 :sex :f :role :child}\n   {:home :south :family \&quot;jones\&quot; :name \&quot;june\&quot; :age 14 :sex :f :role :child}\n\n   {:home :west :family \&quot;brown\&quot; :name \&quot;billie\&quot; :age 55 :sex :f :role :parent}\n   {:home :west :family \&quot;brown\&quot; :name \&quot;brian\&quot; :age 23 :sex :m :role :child}\n   {:home :west :family \&quot;brown\&quot; :name \&quot;bettie\&quot; :age 29 :sex :f :role :child}\n\n   {:home :east :family \&quot;williams\&quot; :name \&quot;walter\&quot; :age 23 :sex :m :role :parent}\n   {:home :east :family \&quot;williams\&quot; :name \&quot;wanda\&quot; :age 3 :sex :f :role :child}\n   ])&quot; &quot;(pprint village\n        )&quot; &quot;\n\n[:require [clojure.core.reducers :as r]\n [clojure.string :as string]]&quot; &quot;(require ['clojure.core.reducers :as r])&quot; &quot;(require [clojure.core.reducers :as r])&quot; &quot;(:require [clojure.string :as str])&quot; &quot;(ns\n  )&quot; &quot;(ns reducer-test &quot; &quot;(ns reducer-test   [:require [clojure.core.reducers :as r]\n                             [clojure.string :as string]])&quot; &quot;(ns reducer-test \n  [:require [clojure.core.reducers :as r]\n            [clojure.string :as string]])&quot; &quot;(clojure-version)&quot; &quot;(require '[clojure.string :as string])&quot; &quot;(require '[clojure.core.reducers :as r])&quot; &quot;(ns)&quot; &quot;(print *ns)&quot; &quot;ns&quot; &quot;namespace&quot; &quot;(range 10)&quot; &quot;(map print inc)&quot; &quot;(map print (range 10))&quot; &quot;(defn anagram? [xs ys]\n  (= (sort xs) (sort ys)))&quot; &quot;(anagram \&quot;tst\&quot; \&quot;tts\&quot;)&quot; &quot;IllegalAccessErrorOf&quot; &quot;(frequencies \&quot;abca\&quot;)&quot; &quot;(doc frequencies)&quot; &quot;(defn anagram? [&amp; xs]\n  (= (map sort xs) ))&quot; &quot;(anagram? \&quot;tst\&quot; \&quot;tts\&quot;)&quot; &quot;(defn anagram? [&amp; xs]\n  (println (map sort xs) ))&quot; &quot;(= (s t t) (s t t) (s s t))&quot; &quot;(apply = (s t t) (s t t) (s s t))&quot; &quot;(apply = '(s t t) '(s t t) '(s s t))&quot; &quot;(defn anagram? [&amp; xs]\n  (apply = (map sort xs) ))&quot; &quot;(anagram? \&quot;tst\&quot; \&quot;tts\&quot; \&quot;sst\&quot;)&quot; &quot;(anagram? \&quot;tst\&quot; \&quot;tts\&quot; \&quot;stt\&quot;)&quot; &quot;(zipmap [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;] (range))&quot; &quot;(zipmap [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;] (range 1))&quot; &quot;(zipmap [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;] (range 1 10))&quot; &quot;(ns ulf.minesweeper)&quot; &quot;(:use clojure.repl)&quot; &quot;(:use clojure.pprint)&quot; &quot;(:use 'clojure.pprint)&quot; &quot;(:use 'clojure.repl)&quot; &quot;(:use 'clojure.core.doc)&quot; &quot;(doc parents)&quot; &quot;(:use 'clojure.core)&quot; &quot;(doc)&quot; &quot;(use 'clojure.core)&quot; &quot;(use 'clojure.pprint)&quot; &quot;(pprint 1)&quot; &quot;(pprint (range 100))&quot; &quot;(use clojure.contrib.repl-utils)&quot; &quot;(use 'clojure.contrib.repl-utils)&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc partial)&quot; &quot;(doc clojure.string/join)&quot; &quot;(str (board-&gt;poster board))&quot; &quot;(apply str (board-&gt;poster board))&quot; &quot;(board-&gt;poster board)&quot; &quot;(map (apply str (board-&gt;poster board)))&quot; &quot;(map (partial apply str) (board-&gt;poster board))&quot; &quot;(map println )&quot; &quot;(map println \n     (map (partial apply str) (board-&gt;poster board)))&quot; &quot;(pprint (map (partial apply str) (board-&gt;poster board)))&quot; &quot;(doc intersect)&quot; &quot;()&quot; &quot;(interpose \n  (map (partial apply str) (board-&gt;poster board))&quot; &quot;(interpose \n  (map (partial apply str) (board-&gt;poster board)) &quot; &quot;(interpose \n  (map (partial apply str) (board-&gt;poster board)) \&quot;\\n\&quot;)&quot; &quot;(interpose \&quot;\\n\&quot;\n  (map (partial apply str) (board-&gt;poster board)))&quot; &quot;     (map (partial apply str) (board-&gt;poster board))&quot; &quot;(map println  (map (partial apply str) (board-&gt;poster board)))&quot; &quot;(print-board board)&quot; &quot;(defn print-board2 \n  [board]\n  (doall (map println \n              \n)))&quot; &quot;(doall (map println (map (partial apply str) (board-&gt;poster board))))&quot; &quot;(doc interleave)&quot; &quot;(doc interpose)&quot; &quot;(def field-&gt;icon \n  {:explored #(\&quot;E\&quot;)\n   :mine #(\&quot;M\&quot;)\n   :warn #(str \&quot;[\&quot; (:warn %) \&quot;]\&quot;)\n   })&quot; &quot;(pprint (range 10))&quot; &quot;(doc map)&quot; &quot;(+ 2 2)&quot; &quot;(iterate rest \&quot;abcd\&quot;)&quot; &quot;(take 10 (iterate rest \&quot;abcd\&quot;))&quot; &quot;(map + [1 0 1] [0 1 0])&quot; &quot;(filter not pos? [1 2 -1])&quot;], :remote []}}</component>
</project>