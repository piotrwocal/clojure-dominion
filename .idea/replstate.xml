<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1422052496612">{:repl-history {:ide [], :local [&quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     #(-&gt;&gt; % first key read-string vec)\n     ;(take 3)\n     ;(subsets 2)\n     pprint)&quot; &quot;((comp vec read-string key first)\n  ([\&quot;(6 6 2 2)\&quot; 14]\n    [\&quot;(6 7 3 2)\&quot; 14]))&quot; &quot;((comp first key read-string vec)\n  ([\&quot;(6 6 2 2)\&quot; 14]\n    [\&quot;(6 7 3 2)\&quot; 14]))&quot; &quot;(map (comp key read-string vec)\n  ([\&quot;(6 6 2 2)\&quot; 14]\n    [\&quot;(6 7 3 2)\&quot; 14]))&quot; &quot;(map (comp vec read-string first)\n  ([\&quot;(6 6 2 2)\&quot; 14]\n    [\&quot;(6 7 3 2)\&quot; 14]))&quot; &quot;(map (comp vec read-string first)\n  '([\&quot;(6 6 2 2)\&quot; 14]\n    [\&quot;(6 7 3 2)\&quot; 14]))&quot; &quot;(defn results-&gt;params\n  [results]\n  (map (comp vec read-string first) results))\n&quot; &quot;(results-&gt;params\n  '([\&quot;(6 6 2 2)\&quot; 14]\n     [\&quot;(6 7 3 2)\&quot; 14]))&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     (subsets 2)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     (subsets 2)\n     results-&gt;params\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (subsets 2)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     params-&gt;strategy\n     (subsets 2)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     first\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     first\n     (play-balanced-series 10)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     first\n     (apply map play-balanced-series 10)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     first\n     map (partial apply play-balanced-series 10)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     first\n     (map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     first\n     (apply play-balanced-series 10)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (apply map play-balanced-series 10)\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map #(apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (best-results 10 [5 7 2 1])\n     ;(take 3)\n     ;results-&gt;params\n     ;(map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial play-balanced-series 10))\n     pprint)&quot; &quot;(defn next-best-params\n  [n params]\n  (-&gt;&gt; (neighbour-results n params) first key read-string vec))&quot; &quot;(defn neighbour-results\n  [n params]\n  (let [best-params params\n        candidates (-&gt; best-params neighbours permutations)\n        best-strategy (params-&gt;strategy best-params)\n        candidates-strategies (map params-&gt;strategy candidates)]\n    (-&gt;&gt; candidates-strategies\n         (map (partial play-balanced-series n best-strategy))\n         (map (partial apply max-key val))\n         (remove #(= (str best-params) (first %)))\n         (sort-by second &gt;))))&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 10))\n     (map (partial apply max-key val))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     ;(take 3)\n     ;results-&gt;params\n     ;(map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 10)\n     ;results-&gt;params\n     ;(map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 100)\n     ;results-&gt;params\n     ;(map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 2)\n     ;results-&gt;params\n     ;(map params-&gt;strategy)\n     ;(subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(play-balanced-series )&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 2)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     ;(map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(-&gt;&gt; (neighbour-results 2 [5 7 2 1])\n     (take 2)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 2))\n     pprint)&quot; &quot;(subsets 1 (range 5))&quot; &quot;(subsets 2 (range 5))&quot; &quot;(subsets 5 (range 5))&quot; &quot;(-&gt;&gt; (neighbour-results 10 [5 7 2 1])\n     (take 3)\n     results-&gt;params\n     (map params-&gt;strategy)\n     (subsets 2)\n     (map (partial apply play-balanced-series 10))\n     pprint)&quot; &quot;(use 'clojure.tools.trace)&quot; &quot;(use 'clojure.contrib.trace)&quot; &quot;(defn ^:dynamic fib [n] (if (&lt; n 2) n (+ (fib (- n 1)) (fib (- n 2)))))&quot; &quot;(dotrace [fib] (fib 3))&quot; &quot;(dotrace (subsets [2 (range 4)]))&quot; &quot;(defn subsets ^:dynamic\n  [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(dotrace [subsets] (subsets [2 (range 4)]))&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (= n 1) (map list items)\n    (empty? items) '()\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    (= n (count items)) items\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(dotrace [subsets] (subsets 3 (range 3)))&quot; &quot;(dotrace [subsets] (subsets 2 (range 3)))&quot; &quot;(dotrace [subsets] (subsets 1 (range 3)))&quot; &quot;map&quot; &quot;(defn ^:dynamic subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    ;(= n (count items)) items\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(dotrace [subsets] (subsets 2 (range 4)))&quot; &quot;(dotrace [subsets] (subsets 2 (range 5)))&quot; &quot;(def ^:dynamic dyn-subsets subsets) &quot; &quot;(dotrace [dyn-subsets] (dyn-subsets 2 (range 5)))&quot; &quot;(defmacro dbg[x] `(let [x# ~x] (println \&quot;dbg:\&quot; '~x \&quot;=\&quot; x#) x#))&quot; &quot;(println (+ (* 2 3) (dbg (* 8 9))))&quot; &quot;(dbg (subsets 2 (range 4)))&quot; &quot;(defn factorial [n]\n  (if (= n 0)\n    1\n    (* n (dbg (factorial (dec n))))))&quot; &quot;(factorial 10)&quot; &quot;(defn subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(trace-vars subsets)&quot; &quot;(subsets 2 (range 4))&quot; &quot;(untrace-vars subsets)&quot; &quot;(trace-vars permutations)&quot; &quot;(permutations [[1 2] [3 4] [5 6]])&quot; &quot;(deftest test-optimized-big-money\n  (are [card board hand]\n    (= card (optimized-big-money board hand))\n    {:province 1} init-board {:copper 8}\n    {:gold 1} init-board {:copper 6}\n    {:duchy 1} {:province 3 :gold 1 :duchy 1} {:copper 6}\n    {:silver 1} init-board {:copper 5}\n    {:silver 1} init-board {:copper 3}\n    {:silver 1} {:province 3 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {:estate 1} {:province 2 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {} init-board {:copper 2}))&quot; &quot;sdf&quot; &quot;(deftest test-optimized-big-money\n  (are [card board hand]\n    (= card (optimized-big-money board hand))\n    {:province 0} init-board {:copper 8}\n    {:gold 1} init-board {:copper 6}\n    {:duchy 1} {:province 3 :gold 1 :duchy 1} {:copper 6}\n    {:silver 1} init-board {:copper 5}\n    {:silver 1} init-board {:copper 3}\n    {:silver 1} {:province 3 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {:estate 1} {:province 2 :gold 0 :duchy 1\n                 :silver   1 :estate 1} {:copper 3}\n    {} init-board {:copper 2}))&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (apply +\n         (map\n           (fn [[card count]] (* (stat (cards-stats card)) count))\n           cards)))&quot; &quot;(count-of :value init-board)&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (reduce\n    (fn [sum [card count]] (* (stat (cards-stats card)) count))\n           cards))&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (reduce\n    (fn [sum [card count]] (+ sum (* (stat (cards-stats card)) count)))\n           cards))&quot; &quot;(defn count-of\n  \&quot;Returns counts of all statistics like :points/:value for given cards.\&quot;\n  [stat cards]\n  (reduce\n    (fn [[card count] sum] (+ sum (* (stat (cards-stats card)) count)))\n           cards))&quot; &quot;(count-of :value init-cards)&quot; &quot;(let [player (atom init-player)\n        hand (take-hand! player)]\n    (is (= init-cards\n           (merge-with + hand (:cards @player))))\n    (is (= init-cards\n           (merge-with + hand (take-hand! player))))\n    (is (and (empty? (take-hand! player))\n             (empty? (:cards @player))\n             (empty? (:discarded @player)))))&quot; &quot;(can buy-? init-cards :province 8)&quot; &quot;(defn can-buy?\n  \&quot;Test if with board and money one can buy card\&quot;\n  [board card money]\n  (and (pos? (card board))\n       (&gt;= money (-&gt; cards-stats card :cost))))&quot; &quot;(defn can-buy?\n  \&quot;Test if with board and money one can buy card\&quot;\n  [board card money]\n  (and (pos? (card board 0))\n       (&gt;= money (-&gt; cards-stats card :cost))))&quot; &quot;(can-buy? init-board :province 5)&quot; &quot;(can-buy? init-board :province 8)&quot; &quot;(can-buy? init-cards :province 8)&quot; &quot;(defn play\n  [&amp; strategies]\n  (let [board (atom init-board)\n        players (map new-player strategies)]\n    (loop [moves '()\n           order (cycle players)]\n      (if (game-finish? board)\n        moves\n        (recur (conj moves (turn board (first order))) (rest order))))))&quot; &quot;(play province-gold-duchy-silver province-gold-silver)&quot; &quot;(play-series 2 province-gold-duchy-silver province-gold-silver)&quot; &quot;(play-series 2 optimized-big-money optimized-big-money)&quot; &quot;(play-series 2 (paramized-big-money* 4 5 2 3)\n             (paramized-big-money* 4 5 2 3))&quot; &quot;(play (paramized-big-money* 4 5 2 3)\n             (paramized-big-money* 4 5 2 3))&quot; &quot;@player&quot; &quot;(pprint @player)&quot; &quot;(turn board player)&quot; &quot;(play )&quot; &quot;(trace-vars turn)&quot; &quot;(defn play\n  [&amp; strategies]\n  (let [board (atom init-board)\n        players (map new-player strategies)]\n    (loop [moves '()\n           order (cycle players)\n           _ (println moves)]\n      (if (game-finish? board)\n        moves\n        (recur (conj moves (turn board (first order))) (rest order))))))&quot; &quot;(def player (new-player \&quot;test\&quot; optimized-big-money))&quot; &quot;(def board (atom init-board))&quot; &quot;(pprint (turn board player))&quot; &quot;(play optimized-big-money optimized-big-money)&quot; &quot;(play [\&quot;first\&quot; optimized-big-money]\n      [\&quot;second\&quot; optimized-big-money])&quot;], :remote []}}</component>
</project>