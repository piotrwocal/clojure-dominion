<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1422994877064">{:repl-history {:ide [], :local [&quot;(defn optimize-iteratively\n  [max-steps params f]\n  (-&gt;&gt; params\n       (iterate f)\n       (find-duplicate max-steps)\n       ))&quot; &quot;(defn find-duplicate\n  ([max coll]\n    (find-duplicate max coll []))\n  ([max coll elements]\n    (let [x (first coll)]\n      (if (or (contains? elements x)\n              (= (count elements) max))\n        [x elements]\n        (recur max (rest coll) (conj elements x))))))&quot; &quot;(find-duplicate 5 [1 2 3 4 5])&quot; &quot;(find-duplicate 5 [1 2 3 3 5])&quot; &quot;(find-duplicate 3 [1 2 3 3 5])&quot; &quot;(find-duplicate 10 [1 2 3 4 5 2])&quot; &quot;(-&gt;&gt; [5 4 3 2]\n     (iterate (partial best-tournament-params 5 5 3))\n     (take 5))&quot; &quot;(find-duplicate 10  '([5 4 3 2] [5 4 3 2] [5 4 3 2] [4 3 3 3] [4 3 3 3]))&quot; &quot;(contains? [[1]] [1])&quot; &quot;(some #{[1]} [[1]])&quot; &quot;(defn optimize-iteratively\n  [max-steps params f]\n  (-&gt;&gt; params\n       (iterate f)\n       (find-duplicate max-steps)))&quot; &quot;(defn find-duplicate\n  ([max coll]\n    (find-duplicate max coll []))\n  ([max coll elements]\n    (let [x (first coll)]\n      (if (or (some #{x} elements)\n              (= (count elements) max))\n        [x elements]\n        (recur max (rest coll) (conj elements x))))))&quot; &quot;(find-duplicate 10 [[1][2][3][2][4]])&quot; &quot;(optimize-iteratively 5 [5 4 3 2] \n                      (partial best-tournament-params 5 5 3))&quot; &quot;(optimize-iteratively 10 [5 4 3 2]\n                      (partial best-neighbour-params 10))&quot; &quot;(defn find-duplicate\n  ([max coll]\n    (find-duplicate max coll []))\n  ([max coll elements]\n    (let [x (first coll)]\n      (if (or (some #{x} elements)\n              (= (count elements) max))\n        [x (conj elements x)]\n        (recur max (rest coll) (conj elements x))))))&quot; &quot;(optimize-iteratively 10 [6 6 2 2] \n                      (partial best-tournament-params 10 10 3))&quot; &quot;(optimize-iteratively 10 [6 7 2 3] \n                      (partial best-tournament-params 20 20 4))&quot; &quot;(optimize-iteratively 10 [6 6 3 2] \n                      (partial best-tournament-params 40 40 4))&quot; &quot;(optimize-iteratively 10 [5 5 3 4] \n                      (partial best-tournament-params 50 100 4))&quot; &quot;(optimize-iteratively 20 [5 5 3 3] \n                      (partial best-tournament-params 100 200 4))&quot; &quot;(play [\&quot;1\&quot; province-gold-duchy-silver]\n      [\&quot;2\&quot;] province-gold-silver)&quot; &quot;(play [\&quot;1\&quot; province-gold-duchy-silver]\n      [\&quot;2\&quot; province-gold-silver])&quot; &quot;(pprint (play [\&quot;1\&quot; province-gold-duchy-silver]\n      [\&quot;2\&quot; province-gold-silver]))&quot; &quot;(file-persisted-action\n  [file action]\n  (fn [board hand]\n    (let [hand (action board hand)]\n      (println hand)\n       hand )))&quot; &quot;(println {:silver 1})&quot; &quot;(defn file-persisted-action\n  [file action]\n  (fn [board hand]\n    (let [hand (action board hand)]\n      (println hand)\n       hand )))&quot; &quot;(defn file-persisted-action\n  [file move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)]\n      (println move-prefix hand)\n       hand )))&quot; &quot;(defn file-persisted-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)]\n      (when-not (.exists (as-file \&quot;myfile.txt\&quot;))\n        )\n      (spit file-name (str move-prefix hand \&quot;\\n\&quot;))\n       hand )))&quot; &quot;(defn file-persisted-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)]\n      (when-not (.exists (as-file \&quot;myfile.txt\&quot;))\n        (spit file-name \&quot;Let's play !\&quot;))\n      (spit file-name (str move-prefix hand \&quot;\\n\&quot;) :append true)\n       hand )))&quot; &quot;(:use 'clojure.pprint)&quot; &quot;(:use clojure.pprint)&quot; &quot;(pprint {})&quot; &quot;(defn file-persisted-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)\n          out-line (str move-prefix \&quot; \&quot; hand \&quot;\\n\&quot;)]\n      (when-not (.exists (as-file \&quot;myfile.txt\&quot;))\n        (spit file-name \&quot;Let's play !\\n\&quot;))\n      (spit file-name out-line :append true)\n      (println out-line)\n       hand )))&quot; &quot;(defn file-persisted-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)\n          out-line (str move-prefix \&quot; \&quot; hand \&quot;\\n\&quot;)]\n      (when-not (.exists (as-file file-name))\n        (spit file-name \&quot;Let's play !\\n\&quot;))\n      (spit file-name out-line :append true)\n      (println out-line)\n       hand )))&quot; &quot;(defn file-persisted-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)\n          out-line (str move-prefix \&quot; \&quot; hand \&quot;\\n\&quot;)]\n      (when-not (.exists (as-file file-name))\n        (do\n          (println \&quot;create file \&quot; file-name)\n          (spit file-name \&quot;Let's play !\\n\&quot;)))\n      (spit file-name out-line :append true)\n      (println out-line)\n       hand )))&quot; &quot;(def verbose-pgds\n  (file-persisted-action \&quot;someFileName\&quot; province-gold-duchy-silver))&quot; &quot;(def verbose-pgds\n  (file-persisted-action \&quot;someFileName\&quot; \&quot;verbose\&quot; province-gold-duchy-silver))&quot; &quot;(pprint (play [\&quot;1\&quot; verbose-pgds]\n      [\&quot;2\&quot; province-gold-silver]))&quot; &quot;(defn file-persisted-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)\n          out-line (str move-prefix \&quot; \&quot; hand \&quot;\\n\&quot;)]\n      (when-not (.exists (as-file file-name))\n        (spit file-name \&quot;Let's play !\\n\&quot;))\n      (spit file-name out-line :append true)\n      hand)))&quot; &quot;(defn file-action \n  [file-name move-prefix]\n  (fn [board hand]\n    (loop [file-content (slurp file-name)]\n      )))&quot; &quot;(line-seq \&quot;test1\\n test2\\n\&quot;)&quot; &quot;(with-open [rdr (reader \&quot;someFileName\&quot;)]\n  (last (line-seq rdr)))&quot; &quot;(with-open [rdr (reader \&quot;someFileName\&quot;)]\n  (let [last-line (last (line-seq rdr))]\n    ))&quot; &quot;(require '[clojure.string :as str])&quot; &quot;(str/split \&quot;verbose {:province 1}\&quot; #\&quot;{\&quot;)&quot; &quot;(str/split \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)&quot; &quot;( \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)&quot; &quot;(str/split \&quot;verbose {:province 1}\&quot; #\&quot; \&quot;)&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc subs)&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot; \&quot;)\n     last\n     (str \&quot;{\&quot;))&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot;{\&quot;)\n     last\n     (str \&quot;{\&quot;))&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)\n     last\n     (str \&quot;{\&quot;))&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)\n     last\n     (str \&quot;{\&quot;)\n     (read-string))&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)\n     last\n     (str \&quot;{\&quot;)\n     (read-string)\n     key)&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)\n     last\n     (str \&quot;{\&quot;)\n     (read-string)\n     first)&quot; &quot;(-&gt;&gt; (str/split \&quot;verbose {:province 1}\&quot; #\&quot;\\{\&quot;)\n     last\n     (str \&quot;{\&quot;)\n     (read-string))\n     &quot; &quot;(key {:province 1})&quot; &quot;(first {:province 1})&quot; &quot;(keys )&quot; &quot;(keys\n  {:province 1})&quot; &quot;(defn line-&gt;buy\n  [line]\n  (-&gt;&gt; (str/split line #\&quot;\\{\&quot;) last (str \&quot;{\&quot;) (read-string)))\n     &quot; &quot;(line-&gt;buy \&quot;vervose {:test 1}\&quot;)&quot; &quot;(defn split-prefx-buy\n  [line]\n  (-&gt;&gt; (str/split line #\&quot;\\{\&quot;) (vec first (last (str \&quot;{\&quot;)))))&quot; &quot;(defn split-prefx-buy\n  [line]\n  (-&gt;&gt; (str/split line #\&quot;\\{\&quot;) ))&quot; &quot;(defn split-prefx-buy\n  [line]\n  (-&gt;&gt; (str/split line #\&quot;\\{\&quot;)))&quot; &quot;(defn split-prefx-buy\n  [line]\n  (let [tokens (str/split line #\&quot;\\{\&quot;)]\n      [(first tokens) (str \&quot;{\&quot; (second tokens))]))&quot; &quot;(defn split-prefx-buy\n  [line]\n  (let [tokens (str/split line #\&quot;\\{\&quot;)]\n      [(.trim (first tokens)) (str \&quot;{\&quot; (second tokens))]))&quot; &quot;(split-prefx-buy \&quot;verbose {:test 1}\&quot;)&quot; &quot;(defn line-&gt;prefix-buy\n  [line]\n  (let [tokens (str/split line #\&quot;\\{\&quot;)]\n    [(.trim (first tokens)) (str \&quot;{\&quot; (second tokens))]))&quot; &quot;(defn line-&gt;prefx-buy\n  [line]\n  (let [tokens (str/split line #\&quot;\\{\&quot;)]\n      [(.trim (first tokens)) (str \&quot;{\&quot; (second tokens))]))&quot; &quot;(defn saving-action\n  [file-name move-prefix action]\n  (fn [board hand]\n    (let [hand (action board hand)\n          out-line (str move-prefix \&quot; \&quot; hand \&quot;\\n\&quot;)]\n      (when-not (.exists (as-file file-name))\n        (spit file-name \&quot;Let's play !\\n\&quot;))\n      (spit file-name out-line :append true)\n      hand)))&quot; &quot;(def verbose-pgds\n  (saving-action \&quot;someFileName\&quot; \&quot;verbose\&quot; province-gold-duchy-silver))\n&quot; &quot;(def verbose-pgds\n  (saving-action \&quot;someFileName\&quot; \&quot;verbose\&quot; province-gold-duchy-silver))\n\n(pprint (play [\&quot;1\&quot; verbose-pgds]\n              [\&quot;2\&quot; province-gold-silver]))&quot; &quot;(line-&gt;prefix-buy \&quot;verbose {:province 1}\&quot;)&quot; &quot;(with-open [rdr (reader \&quot;someFileName\&quot;)]\n  (let [last-line (last (line-seq rdr))\n        [prefix buy] (line-&gt;prefix-buy last-line)]\n    (println prefix \&quot; - \&quot; buy )))\n&quot; &quot;(defn reading-action\n  [file-name move-prefix interval]\n  (fn [board hand]\n    (with-open [rdr (reader file-name)]\n      (let [last-line (last (line-seq rdr))\n            [prefix buy] (line-&gt;prefix-buy last-line)]\n        (if (= move-prefix prefix) \n          buy\n          (do\n            (Thread/sleep interval)\n            (recur file-name move-prefix)))))))&quot; &quot;(defn reading-action\n  [file-name move-prefix interval]\n  (fn [board hand]\n    (with-open [rdr (reader file-name)]\n      (let [last-line (last (line-seq rdr))\n            [prefix buy] (line-&gt;prefix-buy last-line)]\n        (if (= move-prefix prefix) \n          buy\n            (recur file-name move-prefix))))))&quot; &quot;(defn read-prefix-buy\n  [file-name move-prefix]\n  (with-open [rdr (reader file-name)]\n    (let [last line (last (line-seq rdr))]\n      (line-&gt;prefix-buy last-line))))\n&quot; &quot;(defn read-prefix-buy\n  [file-name move-prefix]\n  (with-open [rdr (reader file-name)]\n    (let [last-line (last (line-seq rdr))]\n      (line-&gt;prefix-buy last-line))))\n&quot; &quot;(defn read-prefix-buy\n  [file-name]\n  (with-open [rdr (reader file-name)]\n    (let [last-line (last (line-seq rdr))]\n      (line-&gt;prefix-buy last-line))))\n&quot; &quot;(loop [[prefix buy] (read-prefix-buy \&quot;someFileName\&quot;)]\n  (if (= prefix \&quot;test\&quot;)\n    buy\n    (do\n      (Thread/sleep 1000)\n      (recur (read-prefix-buy)))))&quot; &quot;(loop [[prefix buy] (read-prefix-buy \&quot;someFileName\&quot;)]\n  (if (= prefix \&quot;test\&quot;)\n    buy\n    (do\n      (Thread/sleep 1000)\n      (recur (read-prefix-buy \&quot;someFileName\&quot;)))))&quot; &quot;(take-while (partial not= \&quot;test\&quot;) \n            (repeatedly (fn[] (Thread/sleep 1000) (read-prefix-buy \&quot;someFileName\&quot;))))&quot; &quot;(def read-file (take-while (partial not= \&quot;test\&quot;) \n            (repeatedly (fn[] (Thread/sleep 1000) (read-prefix-buy \&quot;someFileName\&quot;)))))&quot; &quot;(read-file)&quot; &quot;(take 10)&quot; &quot; (some (partial not= \&quot;test\&quot;) \n            (repeatedly (fn[] (Thread/sleep 1000) (read-prefix-buy \&quot;someFileName\&quot;))))&quot; &quot;(some (partial not= \&quot;test\&quot;)\n      (repeatedly (fn [] (Thread/sleep 1000) (read-prefix-buy \&quot;someFileName\&quot;))))&quot; &quot;(take 10 )&quot; &quot;(take 10 (repeatedly (fn [] (Thread/sleep 1000) (read-prefix-buy \&quot;someFileName\&quot;))))&quot; &quot;(defn read-prefix-buy\n  [file-name]\n  (with-open [rdr (reader file-name)]\n    (let [last-line (last (line-seq rdr))]\n      last-line)))&quot; &quot;(read-prefix-buy \&quot;someFileName\&quot;)&quot; &quot;(defn read-prefix-buy\n  [file-name]\n  (with-open [rdr (reader file-name)]\n    (let [last-line (last (line-seq rdr))]\n      (line-&gt;prefix-buy last-line))))&quot; &quot;(defn line-&gt;prefix-buy\n  [line]\n  (let [tokens (str/split line #\&quot;\\{\&quot;)]\n    [(.trim (first tokens)) (read-string (str \&quot;{\&quot; (second tokens)))]))&quot; &quot;(line-&gt;prefix-buy \&quot;test {:someFileName 1}\&quot;)&quot; &quot;(line-&gt;prefix-buy \&quot;test {:gold 1}\&quot;)&quot; &quot;sdfsdfsdf&quot; &quot;(+ 2 2)&quot; &quot;sdf&quot;], :remote []}}</component>
</project>