<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1425931202371">{:repl-history {:ide [], :local [&quot;(let [cards  {:village 1 :cellar 1 :smithy 0 :gold 1}]\n  (filter (fn [[k _]] (k action-stats))\n        (filter (comp pos? val) cards)))&quot; &quot;(let [cards  {:village 1 :cellar 1 :smithy 0 :gold 1}]\n  (into {} (filter (fn [[k _]] (k action-stats))\n        (filter (comp pos? val) cards))))&quot; &quot;(let [cards  {:village 1 :cellar 2 :smithy 0 :gold 1}]\n  (into {} (filter (fn [[k _]] (k action-stats))\n        (filter (comp pos? val) cards))))&quot; &quot;(remove (comp zero? val )  {:village 1 :cellar 2 :smithy 0 :gold 1})\n&quot; &quot;(remove-zero-cards {:test 0})&quot; &quot;(remove-zero-cards {:test 1})&quot; &quot;(filter-actions {:village 1 :cellar 0 :gold 1})&quot; &quot;(count-of :value {:village 1 :cellar 0 :gold 1})&quot; &quot;(count-of :value {:village 1 :cellar 1 :gold 1})&quot; &quot;(def all-cards-stats (into base-cards-stats action-stats))&quot; &quot;all-cards-stats&quot; &quot;(pprint all-cards-stats)&quot; &quot;(count-of-all :value {:village 1 :cellar 1 :gold 1})&quot; &quot;(count-of-all :cost {:village 1 :cellar 1 :gold 1})&quot; &quot;(let [cards {:village 1 :cellar 1 :gold 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio ( / (count-of-all :cost action-cards) 2)]\n  ( / (+ total-value action-ratio) (count cards)))&quot; &quot;(let [cards {:village 1 :cellar 1 :gold 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 5}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 0}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 3 :estate 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 4}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(count {:gold 1 :estate 4})&quot; &quot;(let [cards {:gold 1 :copper 0}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 5}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 4}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :village 2 :estate 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 4}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:silver 2 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:labolatory 2 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 2 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(defn weighted-money-generation\n  [cards]\n  (let [all-values (count-of-all :value cards)\n        action-cards (filter-actions cards)\n       action-ratio (/ (count-of-all :cost action-cards) 2)]\n      (/ (+ total-value action-ratio) (count-cards cards))))\n&quot; &quot;(defn weighted-money-generation\n  [cards]\n  (let [all-values (count-of-all :value cards)\n        action-cards (filter-actions cards)\n       action-ratio (/ (count-of-all :cost action-cards) 2)]\n      (/ (+ all-values action-ratio) (count-cards cards))))\n&quot; &quot;(if 0 \&quot;true\&quot;)&quot; &quot;(defn weighted-money-generation\n  [cards]\n  (if (zero? (count-cards cards ))\n    0\n  (/ (+ (count-of-all :value cards)\n        (/ (count-of-all :cost (filter-actions cards)) 2))\n     (count-cards cards))))&quot; &quot;(defmulti play-card\n          \&quot;Plays single card according to rules modifying accordingly board/player/state.\&quot;\n          (fn [card board player hand state] card)\n          :default nil)&quot; &quot;(weighted-money-generation {})&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (k action-stats))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] #(:estate) k )\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] #(:estate) k )\n                   cards)))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (#(:estate) k ))\n                   cards)))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (k #(:estate)))\n                   cards)))&quot; &quot;(filter #{:estate)&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (#{:estate} k))\n                   cards)))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (#{:estate} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1 :province 1}]\n  (into {} (filter (fn [[k _]] (#{:estate} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1 :province 1}]\n  (into {} (filter (fn [[k _]] (#{:estate :province} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1 :province 0}]\n  (into {} (filter (fn [[k _]] (#{:estate :province} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(defn filter-points\n  [cards]\n  (into {} (filter (fn [[k _]] (#{:estate :duchy :province} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(filter-points {:estate 1 :province 0 :village 1})&quot; &quot;(defn filter-points\n  [cards]\n  (into {} (filter (comp #{:estate :duchy :province} key)\n                   (filter (comp pos? val) cards))))&quot; &quot;(filter-points {:duchy 1 :village 2 :estate 0})&quot; &quot;(filter-points {})&quot; &quot;(filter-points {:duchy 0})&quot; &quot;(dissoc {:duchy 1 :village 2 :estate 0} (keys {:duchy 1}))&quot; &quot;(apply dissoc {:duchy 1 :village 2 :estate 0} (keys {:duchy 1}))&quot; &quot;(conj [] {:estate 0, :village 2})&quot; &quot;(apply conj [] {:estate 0, :village 2})&quot; &quot;(conj {:test 1} {:other 2})&quot; &quot;(choose-action nil nil {:cellar 1 :smithy 1} init-move-state)&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc choose-action)&quot; &quot;(source 'choose-action)&quot; &quot;(source choose-action)&quot; &quot;(eval-actions [:cellar :smithy])&quot; &quot;(eval-actions [:smithy :cellar])&quot; &quot;(read-string \&quot;12.3\&quot;)&quot; &quot;(re-seq #\&quot;;\&quot; \&quot;1;2;3;4\&quot;)&quot; &quot;(dotrace subsets)&quot; &quot;(trace-vars 'subsets)&quot; &quot;(defn subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(trace-vars subsets)&quot; &quot;(subsets (range 6))&quot; &quot;(subsets 2(range 6))&quot; &quot;(subsets 2(range 5))&quot; &quot;(subsets 2(range ))&quot; &quot;(subsets 2(range 4))&quot; &quot;(defmacro dbg[x] `(let [x# ~x] (println \&quot;dbg:\&quot; '~x \&quot;=\&quot; x#) x#))&quot; &quot;(let [x (range 6)])&quot; &quot;(let [x (dbg (range 6))])&quot; &quot;(defn results-&gt;params\n  [result]\n  (map (comp vec read-string first) result))&quot; &quot;(subsets 2 (range 5))&quot; &quot;(eval-actions :moat :chancellor)&quot; &quot;(apply eval-actions :moat :chancellor)&quot; &quot;(eval-actions [:moat :chancellor])&quot; &quot;(eval-actions [:chancellor :moat])&quot; &quot;(defn simple-buy*\n  [&amp; prefered]\n  (fn [board hand]\n    (let [money (count-of-base :value hand)\n          buy (first (filter #(can-buy? board % money) prefered))\n          _ (println \&quot;money=\&quot; money \&quot;, buy=\&quot; buy)]\n      (if buy {buy 1} {}))))&quot; &quot;(def province-gold-duchy-silver\n  (simple-buy* :province :gold :duchy :silver))&quot; &quot;(optimized-big-money (atom init-board) {:cooper 6})&quot; &quot;(optimized-big-money (atom init-board) {:copper 6})&quot; &quot;(optimized-big-money (atom init-board) {:gold 2})&quot; &quot;(optimized-big-money (init-board) {:gold 2})&quot; &quot;(optimized-big-money init-board {:gold 2})&quot;], :remote []}}</component>
</project>