<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1432158087480">{:repl-history {:ide [], :local [&quot;(let [cards {:gold 1 :estate 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 4}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(count {:gold 1 :estate 4})&quot; &quot;(let [cards {:gold 1 :copper 0}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 1}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 5}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :copper 4}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :village 2 :estate 2}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 1 :estate 4}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:silver 2 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:labolatory 2 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(let [cards {:gold 2 :estate 3}\n      total-value (count-of-all :value cards)\n      action-cards (filter-actions cards)\n      action-ratio (/ (count-of-all :cost action-cards) 2)\n      result (/ (+ total-value action-ratio) (count-cards cards))]\n  [total-value action-cards action-ratio result])&quot; &quot;(defn weighted-money-generation\n  [cards]\n  (let [all-values (count-of-all :value cards)\n        action-cards (filter-actions cards)\n       action-ratio (/ (count-of-all :cost action-cards) 2)]\n      (/ (+ total-value action-ratio) (count-cards cards))))\n&quot; &quot;(defn weighted-money-generation\n  [cards]\n  (let [all-values (count-of-all :value cards)\n        action-cards (filter-actions cards)\n       action-ratio (/ (count-of-all :cost action-cards) 2)]\n      (/ (+ all-values action-ratio) (count-cards cards))))\n&quot; &quot;(if 0 \&quot;true\&quot;)&quot; &quot;(defn weighted-money-generation\n  [cards]\n  (if (zero? (count-cards cards ))\n    0\n  (/ (+ (count-of-all :value cards)\n        (/ (count-of-all :cost (filter-actions cards)) 2))\n     (count-cards cards))))&quot; &quot;(defmulti play-card\n          \&quot;Plays single card according to rules modifying accordingly board/player/state.\&quot;\n          (fn [card board player hand state] card)\n          :default nil)&quot; &quot;(weighted-money-generation {})&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (k action-stats))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] #(:estate) k )\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] #(:estate) k )\n                   cards)))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (#(:estate) k ))\n                   cards)))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (k #(:estate)))\n                   cards)))&quot; &quot;(filter #{:estate)&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (#{:estate} k))\n                   cards)))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1}]\n  (into {} (filter (fn [[k _]] (#{:estate} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1 :province 1}]\n  (into {} (filter (fn [[k _]] (#{:estate} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1 :province 1}]\n  (into {} (filter (fn [[k _]] (#{:estate :province} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(let [cards {:village 1 :estate 1 :copper 1 :province 0}]\n  (into {} (filter (fn [[k _]] (#{:estate :province} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(defn filter-points\n  [cards]\n  (into {} (filter (fn [[k _]] (#{:estate :duchy :province} k))\n                   (filter (comp pos? val) cards))))&quot; &quot;(filter-points {:estate 1 :province 0 :village 1})&quot; &quot;(defn filter-points\n  [cards]\n  (into {} (filter (comp #{:estate :duchy :province} key)\n                   (filter (comp pos? val) cards))))&quot; &quot;(filter-points {:duchy 1 :village 2 :estate 0})&quot; &quot;(filter-points {})&quot; &quot;(filter-points {:duchy 0})&quot; &quot;(dissoc {:duchy 1 :village 2 :estate 0} (keys {:duchy 1}))&quot; &quot;(apply dissoc {:duchy 1 :village 2 :estate 0} (keys {:duchy 1}))&quot; &quot;(conj [] {:estate 0, :village 2})&quot; &quot;(apply conj [] {:estate 0, :village 2})&quot; &quot;(conj {:test 1} {:other 2})&quot; &quot;(choose-action nil nil {:cellar 1 :smithy 1} init-move-state)&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc choose-action)&quot; &quot;(source 'choose-action)&quot; &quot;(source choose-action)&quot; &quot;(eval-actions [:cellar :smithy])&quot; &quot;(eval-actions [:smithy :cellar])&quot; &quot;(read-string \&quot;12.3\&quot;)&quot; &quot;(re-seq #\&quot;;\&quot; \&quot;1;2;3;4\&quot;)&quot; &quot;(dotrace subsets)&quot; &quot;(trace-vars 'subsets)&quot; &quot;(defn subsets\n  [n items]\n  (cond\n    (empty? items) '()\n    (= n 1) (map list items)\n    :else (concat (map\n                    (partial cons (first items))\n                    (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))&quot; &quot;(trace-vars subsets)&quot; &quot;(subsets (range 6))&quot; &quot;(subsets 2(range 6))&quot; &quot;(subsets 2(range 5))&quot; &quot;(subsets 2(range ))&quot; &quot;(subsets 2(range 4))&quot; &quot;(defmacro dbg[x] `(let [x# ~x] (println \&quot;dbg:\&quot; '~x \&quot;=\&quot; x#) x#))&quot; &quot;(let [x (range 6)])&quot; &quot;(let [x (dbg (range 6))])&quot; &quot;(defn results-&gt;params\n  [result]\n  (map (comp vec read-string first) result))&quot; &quot;(subsets 2 (range 5))&quot; &quot;(eval-actions :moat :chancellor)&quot; &quot;(apply eval-actions :moat :chancellor)&quot; &quot;(eval-actions [:moat :chancellor])&quot; &quot;(eval-actions [:chancellor :moat])&quot; &quot;(defn simple-buy*\n  [&amp; prefered]\n  (fn [board hand]\n    (let [money (count-of-base :value hand)\n          buy (first (filter #(can-buy? board % money) prefered))\n          _ (println \&quot;money=\&quot; money \&quot;, buy=\&quot; buy)]\n      (if buy {buy 1} {}))))&quot; &quot;(def province-gold-duchy-silver\n  (simple-buy* :province :gold :duchy :silver))&quot; &quot;(optimized-big-money (atom init-board) {:cooper 6})&quot; &quot;(optimized-big-money (atom init-board) {:copper 6})&quot; &quot;(optimized-big-money (atom init-board) {:gold 2})&quot; &quot;(optimized-big-money (init-board) {:gold 2})&quot; &quot;(optimized-big-money init-board {:gold 2})&quot; &quot;(optimized-big-money init-board init-player)&quot; &quot;(optimized-big-money init-board init-cards)&quot; &quot;init-cards&quot; &quot;(optimized-big-money init-board {:copper 7})&quot; &quot;(optimized-big-money init-board {:copper 15})&quot; &quot;(optimized-big-money init-board {:copper 14})&quot; &quot;(dotimes (println \&quot;\&quot;))&quot; &quot;(dotimes 10 (println \&quot;\&quot;))&quot; &quot;send-off&quot; &quot;sdf&quot; &quot;(defn paramized-big-money*\n  [gold-min-p duchy-max-p silver-min-p estate-max-p]\n  (fn [board hand]\n    (let [value (count-of-base :value hand)\n          provinces (:province board 0)\n          _ (println \&quot;executed paramized-big-money hand=\&quot; hand)]\n      (cond\n        (can-buy? board :province value) {:province 1}\n        (and (can-buy? board :gold value) (&gt;= provinces gold-min-p)) {:gold 1}\n        (and (can-buy? board :duchy value) (&lt;= provinces duchy-max-p)) {:duchy 1}\n        (and (can-buy? board :silver value) (&gt;= provinces silver-min-p)) {:silver 1}\n        (and (can-buy? board :estate value) (&lt;= provinces estate-max-p)) {:estate 1}\n        :else {}))))&quot; &quot;(defn buy-card\n  [board player hand state]\n  (let [action (:action @player)\n        buy (if action (action board hand) {:upps})\n        _ (println \&quot;buy-card executed, hand=\&quot; hand \&quot;, state=\&quot; state \&quot;, action=\&quot; action \&quot;,buy\&quot; buy)]\n    (single-action board player hand\n                   (update-in state [:played] conj buy))))&quot; &quot;(defn buy-card\n  [board player hand state]\n  (let [action (:action @player)\n        buy (if action (action board hand) {:upps 1} )\n        _ (println \&quot;buy-card executed, hand=\&quot; hand \&quot;, state=\&quot; state \&quot;, action=\&quot; action \&quot;,buy\&quot; buy)]\n    (single-action board player hand\n                   (update-in state [:played] conj buy))))&quot; &quot;(defn paramized-big-money*\n  [gold-min-p duchy-max-p silver-min-p estate-max-p]\n  (fn [board hand]\n    (let [value (count-of-base :value hand)\n          provinces (:province board 0)\n          _ (println \&quot;executed paramized-big-money hand=\&quot; hand)]\n      (cond\n        (can-buy? board :province value) {:province 1}\n        (and (can-buy? board :gold value) (&gt;= provinces gold-min-p)) {:gold 1}\n        (and (can-buy? board :duchy value) (&lt;= provinces duchy-max-p)) {:duchy 1}\n        (and (can-buy? board :silver value) (&gt;= provinces silver-min-p)) {:silver 1}\n        (and (can-buy? board :estate value) (&lt;= provinces estate-max-p)) {:estate 1}\n        :else {:cannot-buy 1}))))&quot; &quot;(defn buy-card\n  [board player hand state]\n  (let [action (:action @player)\n        buy (if action (action @board hand) {:upps 1} )\n        _ (println \&quot;buy-card executed, hand=\&quot; hand \&quot;, state=\&quot; state \&quot;, action=\&quot; action \&quot;,buy\&quot; buy)]\n    (single-action board player hand\n                   (update-in state [:played] conj buy))))&quot; &quot;(deftest test-buy-card\n  (are [hand init-player result-player]\n    (= (select-keys (single-action (atom init-board)\n                                   (atom (conj init-player {:action optimized-big-money}))\n                                   hand init-move-state)\n                    [:cards :discarded])\n       result-player)\n\n    ; double buy with add-money counted\n    {:woodcutter 1 :copper 12} {:cards {:estate 1} :discarded {}}\n    {:cards {:estate 1} :discarded {:woodcutter 1 :copper 12 :province 1 :gold 1}}\n    ))&quot; &quot;(seq? {})&quot; &quot;(seq? {:a 1})&quot; &quot;(empty? {:a 1})&quot; &quot;(empty? {})&quot; &quot;(empty {})&quot; &quot;(empty {:a 1})&quot; &quot;(apply + (range 10))&quot; &quot;(def action-stats\n  \&quot;Action cards statistics as a map of cards type (:copper etc) to stats map\&quot;\n  {:cellar       {:cost 2 :add-action 1}\n   :chapel       {:cost 2}\n   :moat         {:cost 3 :add-card 2}\n   :chancellor   {:cost 3 :add-money 2}\n   :village      {:cost 3 :add-action 2 :add-card 1}\n   :woodcutter   {:cost 3 :add-money 2 :add-buy 1}\n   :workshop     {:cost 3}\n   :bureaucat    {:cost 4}\n   :feast        {:cost 4}\n   :militia      {:cost 4 :add-money 2}\n   :moneylender  {:cost 4}\n   :remodel      {:cost 4}\n   :smithy       {:cost 4 :add-card 3}\n   :spy          {:cost 4 :add-action 1 :add-card 1}\n   :thief        {:cost 4}\n   :throne-room  {:cost 4}\n   :council-room {:cost 5 :add-card 4 :add-buy 1}\n   :festival     {:cost 5 :add-action 2 :add-buy 1 :add-money 2}\n   :labolatory   {:cost 5 :add-action 1 :add-card 2}\n   :library      {:cost 5}\n   :market       {:cost 5 :add-action 1 :add-card 1 :add-buy 1 :add-money 1}\n   :mine         {:cost 5}\n   :witch        {:cost 5 :add-card 2}\n   :adventurer   {:cost 6}\n   })&quot; &quot;(def init-move-state\n  {:free-action 1 :free-buy 1 :virtual-money 0 :played []})&quot;], :remote []}}</component>
</project>