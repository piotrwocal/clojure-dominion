<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1425422301001">{:repl-history {:ide [], :local [&quot;(defmethod play-card nil\n  [card board player hand state]\n  (do \n    (println \&quot;Default action for nil card value\&quot;)\n    (single-action board player hand state)))&quot; &quot;(def test-player (atom init-player))&quot; &quot;(single-action test-board test-player\n               {:village 1 :copper 1 :cellar 1} \n               init-move-state)&quot; &quot;(run-all-test)&quot; &quot;(run-all-tests)&quot; &quot;(run-all-tests #\&quot;clojure-dominion.*\&quot;)&quot; &quot;(run-all-tests #\&quot;clojure-dominion.core-test\&quot;)&quot; &quot;(deftest test-count-cards\n  (are [result cards]\n    (= (count-cards cards) result)\n    10 init-cards\n    6 {:copper 1, :silver 2, :gold 3}\n    0 {}))&quot; &quot;(deftest test-filter-actions\n  (are [result cards]\n    (= (filter-actions cards) result)\n    10 init-cards\n    6 {:copper 1, :silver 2, :gold 3}\n    0 {}))&quot; &quot;(filter-actions {:village 0 :cellar 2})&quot; &quot;(deftest test-filter-actions\n  (are [result cards]\n    (= (filter-actions cards) result)\n    [:village :cellar]  {:village 1 :cellar 1 :gold 1}\n    []                  init-cards))&quot; &quot;(filter-actions {:village 1 :cellar 2})&quot; &quot;(map key {:village 1 :cellar 2})&quot; &quot;(deftest test-filter-actions\n  (are [result cards]\n    (= (set (filter-actions cards)) (set result))\n    [:village :cellar]  {:village 1 :cellar 1 :gold 1}\n    []                  init-cards))&quot; &quot;(eval-actions action-stats)&quot; &quot;(eval-actions (keys action-stats))&quot; &quot;(def result (eval-actions (keys action-stats)))&quot; &quot;result&quot; &quot;(remove (set result) action-stats)&quot; &quot;(remove (set result) (keys action-stats))&quot; &quot;(pprint (remove (set result) (keys action-stats)))&quot; &quot;(use 'clojure.test)&quot; &quot;(run-tests 'clojure-dominion.action)&quot; &quot;(run-tests 'clojure-dominion.action-test)&quot; &quot;test-board&quot; &quot;\n{:cards {:copper 4, :estate 1}, :discarded {}}&quot; &quot;test-board\n\n{:cards {:copper 4, :estate 1}, :discarded {}}&quot; &quot;(def test-player (atom  {:cards {:estate 1}, :discarded {}}))&quot; &quot;(swap! test-player (atom  {:cards {:estate 1}, :discarded {}}))&quot; &quot;(doc swap!)&quot; &quot;(defn action-turn\n  \&quot;Executes full player turn, executing action(s) and buy(s)\&quot;\n  [board player]\n  (single-action board player (take-from-deck! 5 player) init-move-state))&quot; &quot;(reset! test-player\n  {:cards {:estate 1}, :discarded {}})&quot; &quot;(single-action test-board test-player\n               {:village 1 :cooper 1 :cellar 1} \n               init-move-state)&quot; &quot;init-move-state&quot; &quot;(defn filter-actions\n  \&quot;Takes cards and returns coll of action keywords for which cards count is positive\&quot;\n  [cards]\n  (map key\n       (filter (fn [[k _]] (k action-stats))\n               (filter (comp pos? val) cards))))&quot; &quot;(assoc-in init-move-state [:played] {:village 1})&quot; &quot;(def test-move-state (conj-in init-move-state [:played] {:village 1}))&quot; &quot;(def test-move-state (assoc-in init-move-state [:played] {:village 1}))&quot; &quot;test-move-state&quot; &quot;(assoc-in test-move-state [:played] {:chapel 1})&quot; &quot;(update-in\n  [:played]\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n  conj {:vllage 1})&quot; &quot;(update-in\n  [:played]\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n  assoc {:vllage 1})&quot; &quot;(assoc-in\n  [:played]\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n   {:vllage 1})&quot; &quot;(update-in\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n  [:played]\n  {:vllage 1})&quot; &quot;(update-in\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n  [:played]\n  conj\n  {:vllage 1})&quot; &quot;(update-in\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n  [:played]\n  conj\n  {:village 1})&quot; &quot;(update-in\n  {:free-action 1, :free-buy 1, :virtual-money 0, :played [{:thief 1}]}\n  [:played]\n  conj\n  {:village 1})&quot; &quot;(merge-with - \n  {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n  {:free-action 1})&quot; &quot;(--&gt; {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n     (merge-with - {:free-action 1}))&quot; &quot;(-&gt; {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n&quot; &quot;(-&gt; {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n     (merge-with - {:free-action 1}))&quot; &quot;(-&gt;&gt; {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n     (merge-with - {:free-action 1}))&quot; &quot;(-&gt;&gt; {:free-action 1, :free-buy 1, :virtual-money 0, :played []}\n     (merge-with - {:free-action 2}))&quot; &quot;(-&gt;&gt; {:free-action 2, :free-buy 1, :virtual-money 0, :played []}\n     (merge-with - {:free-action 1}))&quot; &quot;(let[ state {:free-action 2, :free-buy 1, :virtual-money 0, :played []}\n      state (merge-with - {:free-action 1})\n      state (update-in state [:played] conj {:village 1})]\n  (ppring state))\n&quot; &quot;(use 'clojure.pprint)&quot; &quot;(let[ state {:free-action 2, :free-buy 1, :virtual-money 0, :played []}\n      state (merge-with - {:free-action 1})\n      state (update-in state [:played] conj {:village 1})]\n  (pprint state))\n&quot; &quot;(-&gt; {:free-action 2, :free-buy 1, :virtual-money 0, :played []}\n    (partial merge-with -) {:free-action 1})&quot; &quot;(-&gt; {:free-action 2, :free-buy 1, :virtual-money 0, :played []}\n    (partial merge-with) - {:free-action 1})&quot; &quot;(let[ state {:free-action 2, :free-buy 1, :virtual-money 0, :played []}\n      state (merge-with - state {:free-action 1})\n      state (update-in state [:played] conj {:village 1})]\n  (pprint state))\n&quot; &quot;(defn update-move-state\n  [state action]\n  (let [new-state (merge-with - state {:free-action 1})]\n    (update-in new-state [:played] conj {action 1})))\n&quot; &quot;(update-move-state {:free-action 2, :free-buy 1, :virtual-money 0, :played []} :village)&quot; &quot;(update-move-state {:free-action 2, :free-buy 1, :virtual-money 0, :played [{:village 1}]} :village)&quot; &quot;(def test-board (atom init-board))\n(def test-player (atom init-cards))&quot; &quot;(cond \n  (nil) \&quot;false\&quot;\n  ({:village 1} \&quot;lets play\&quot;))&quot; &quot;(cond \n  nil \&quot;false\&quot;\n  ({:village 1} \&quot;lets play\&quot;))&quot; &quot;(cond \n  nil \&quot;false\&quot;\n  {:village 1} \&quot;lets play\&quot;)&quot; &quot;()&quot; &quot;(single-action test-board test-player\n               {:village 1} \n               init-move-state)&quot; &quot;(reset! test-player init-cards)&quot; &quot;@test-player&quot; &quot;(take-cards! 1 test-player)&quot; &quot;(reset! test-player init-player)&quot; &quot;(single-action test-board test-player\n               {:village 1 :gold 1} \n               init-move-state)&quot; &quot;(single-action nil (atom {:cards {:estate 2}, :discarded {}})\n               {:village 1 :gold 1} init-move-state)\n&quot; &quot;(single-action (atom init-board)\n               (atom {:cards {:estate 2}, :discarded {}})\n               {:village 1 :gold 1} init-move-state)\n&quot; &quot;(def test-player \n  (atom {:cards init-cards :discarded {:gold 1}}))\n  &quot; &quot;test-player&quot; &quot;(defn has-discarded?\n  \&quot;Check if player has discarded cards\&quot;\n  [player]\n  (-&gt; (player :discarded) count-cards pos?))&quot; &quot;init-cards&quot; &quot;(-&gt;&gt; init-cards\n     map :value)&quot; &quot;(-&gt;&gt; init-cards\n     (map :value)\n     )&quot; &quot;(count-of :value init-cards)&quot; &quot;(filter-actions init-cards)&quot; &quot;(filter-actions {:village 1})&quot; &quot;(filter-actions {:village 1 :smithy 1})&quot; &quot;(set (filter-actions {:village 1 :cellar 0 :gold 1}))&quot; &quot;1&quot; &quot;(set (filter-actions {:village 1 :cellar 1 :gold 1}))&quot; &quot;(let [cards  {:village 1 :cellar 1 :smithy 0 :gold 1}]\n  (filter (fn [[k _]] (k action-stats))\n        (filter (comp pos? val) cards)))&quot; &quot;(let [cards  {:village 1 :cellar 1 :smithy 0 :gold 1}]\n  (into {} (filter (fn [[k _]] (k action-stats))\n        (filter (comp pos? val) cards))))&quot; &quot;(let [cards  {:village 1 :cellar 2 :smithy 0 :gold 1}]\n  (into {} (filter (fn [[k _]] (k action-stats))\n        (filter (comp pos? val) cards))))&quot; &quot;(remove (comp zero? val )  {:village 1 :cellar 2 :smithy 0 :gold 1})\n&quot; &quot;(remove-zero-cards {:test 0})&quot; &quot;(remove-zero-cards {:test 1})&quot; &quot;(filter-actions {:village 1 :cellar 0 :gold 1})&quot; &quot;(count-of :value {:village 1 :cellar 0 :gold 1})&quot; &quot;(count-of :value {:village 1 :cellar 1 :gold 1})&quot; &quot;(def all-cards-stats (into base-cards-stats action-stats))&quot; &quot;all-cards-stats&quot; &quot;(pprint all-cards-stats)&quot;], :remote []}}</component>
</project>